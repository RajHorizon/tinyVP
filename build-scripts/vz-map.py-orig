#!/usr/bin/python

import os

from pprint import pprint
import pprint
import sys

import vzparser
from vzparser import *

KB = 1024

romaddress = None
romend = None
ramaddress = None
ramend = None
vzcode = None
vzentry = None
vzdata = None
vzstacktop = None

class MyPrettyPrinter(pprint.PrettyPrinter):
    def format(self, object, context, maxlevels, level):
	if isinstance(object, int):
	    return hex(object), True, False
	else:
	    return pprint.PrettyPrinter.format(self, object, context, maxlevels, level)

def parse_platform(arg):
    global romaddress, romend, ramaddress, ramend, vzcode, vzentry, vzdata, vzstacktop
    f = open(arg)
    for line in f:
	# First, remove comments:
	if COMMENT_CHAR in line:
	    # split on comment char, keep only the part before
	    line, comment = line.split(COMMENT_CHAR, 1)
	line = line.strip()
	if '=' in line:
	    key, value = line.split('=', 1)
	    key = key.strip()
	    value = value.strip()
	    if key == "rom":
		romaddress, romend = value.split()
		romaddress = int(romaddress,0)
		romend = int(romend,0)
	    if key == "ram":
		ramaddress, ramend = value.split()
		ramaddress = int(ramaddress,0)
		ramend = int(ramend,0)
	    if key == "vzcode":
		vzcode = int(value,0)
	    if key == "vzentry":
		vzentry = int(value,0)
	    if key == "vzdata":
		vzdata = int(value,0)
	    if key == "vzstacktop":
		vzstacktop = int(value,0)
    f.close()

def parse_config(filename):
    vm = parse_config_file(filename, "map")

def kphys(arg):
    return int(arg,0) & 0x1fffffff

def round_region(size, align):
    return (int(size,0) + (4*KB - 1)) & ~(4*KB - 1)

def allocate_region(paddr, size, flags, align, ramflag):
    global romaddress, romend, ramaddress, ramend, vzcode, vzentry, vzdata, vzstacktop
    if ramflag == 0:
	newpaddr = romaddress
	newpaddr = (newpaddr + (int(align,0) - 1)) & ~(int(align,0) - 1)
	romaddress = newpaddr + size
	if romaddress >= romend:
	    print "ROM space is exhausted with ",paddr," region"
	    exit()
    else:
	newpaddr = ramaddress
	newpaddr = (newpaddr + (int(align,0) - 1)) & ~(int(align,0) - 1)
	ramaddress = newpaddr + size
	if ramaddress >= ramend:
	    print "RAM space is exhausted with ",paddr," region"
	    exit()
    return (paddr, size, flags, newpaddr), newpaddr - paddr

parse_platform(sys.argv[1])
parse_devicelib("device.lib")
parse_config(sys.argv[2])
mpp2 = MyPrettyPrinter()
mpp2.pprint(configuration)
if (len(sys.argv) < 4) or (sys.argv[3] != "maps"):
    objcopy = []
    for vmid in configuration:
	vm = configuration[vmid]
	offset = 0
	if "mmap" in vm:
	    newmmap = []
	    for region in vm["mmap"]:
		if region[4] == 0:
		    # reserve_region(region) -- not today
		    continue
		paddr = kphys(region[0])
		size = round_region(region[1], region[3])
		if 'w' not in region[2]:
		    newregion, offset = allocate_region(paddr, size, region[2], region[3], 0)
		else:
		    newregion, offsetrw = allocate_region(paddr, size, region[2], region[3], 1)
		newmmap.append(newregion)
	    if "elf" in vm:
		mapname = os.path.splitext(vm["elf"])[0]+'.map'
		cfgname = os.path.splitext(vm["elf"])[0]+'.cfg'
		creat_cfg = 0
		if not os.path.isfile(cfgname):
		    creat_cfg = 1
		else:
		    mapstatinfo = os.stat(mapname)
		    cfgstatinfo = os.stat(cfgname)
		#print 'cfgname',cfgname,' creat_cfg',creat_cfg
		if (creat_cfg == 1) or (mapstatinfo.st_mtime > cfgstatinfo.st_mtime):
		    fl = open(cfgname, "w")
		    if "entry" in vm:
			print >>fl, "\tentry =",vm["entry"]
		    print >>fl, "\t.mmap"
		    for region in newmmap:
			if "w" not in region[2]:
			    print >>fl, "\t\tcode = 0x%08x 0x%x %s 0x%08x" % (region[0], region[1], region[2], region[3])
			else:
			    print >>fl, "\t\tdata = 0x%08x 0x%x %s 0x%08x" % (region[0], region[1], region[2], region[3])
		    print >>fl, "\t."
		    fl.close()
	    print "VM",str(vm["id"]),":"
	    for region in newmmap:
		print region
	if "file" in vm:
	    cmdname = os.path.splitext(vm["file"])[0]+'.cmd'
	    if os.path.isfile(cmdname):
		fl = open(cmdname)
		for line in fl:
		    line = line.replace("$OFFSET", hex(offset))
		    objcopy.append(line)
		fl.close()
    # create a final shell cmd to all objects merge
    flname = sys.argv[2] + '.objcopy'
    fl = open(flname, "w")
    for line in objcopy:
	print >>fl, line,
    print >>fl, "srec_cat a.out.srec",
    for vmid in configuration:
	vm = configuration[vmid]
	if "file" in vm:
	    filename = os.path.splitext(vm["file"])[0]+".srec"
	    print >>fl, " ", filename,
    print >>fl, " >a.merged.srec"
    fl.close()
    os.system("chmod +x " + flname)
