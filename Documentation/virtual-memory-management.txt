	    tinyVP virtual memory management
		    Leonid Yegoshin
			1/16/18


PART A:     Guest "physical" memory management by root
------------------------------------------------------

  All tables in this section are generated by desktop Python configurator into pte.c
and sit in flash Read-Only memory.
  All code which processes this tables is located in files tlb.c and, to some
extent - in start.S (TLB refill handler and a simple 'absent guest' TLB tree)



    1.  Root PTEs (Page Table Elements) trees structure


A root array cpte_base[] is an array of pointers to each thread PTE tree.

	 cpte_base[] is ptrs to:    thread0 (root itself)
				    thread1
				    thread2 (guest 2)
				    thread3
				       ...
				    thread7 (guest 7)

Each thread tree starts from 8 PTE elements describing eight 512MB
regions aka 2*256MB pages. Pairing is an essential part of MIPS R2+ MMU,
and 256MB is a biggest page size in MIPS R2+.

In most cases the big pages are not that is needed for guest, and more
precise split is needed with more smaller page sizes. So, at any point
the intermediate node is needed which points to a block of smaller pages
and intermediate nodes for even smaller pages:

    thread 1:   PTE512
		PTE512
		intermediate    --> PTExxx
				    PTExxx
			...
		PTE512
		intermediate    --> intermediate    --> PTEyyy
				    PTExxx              PTEyyy
				    PTExxx
				    PTExxx
				    tranasient  --> SW PTEzzz
						    SW intermediate
						    ...
				    PTExxx
			...


Format of intermediate node is:

	    struct cpte_nd {
		    union  cpte         const * const next;
		    unsigned long       mask;
		    unsigned long       golden;
		    BITFIELD_FIELD(unsigned long pm : 20,
		    BITFIELD_FIELD(unsigned long rs : CPTE_SHIFT_SIZE,
		    BITFIELD_FIELD(unsigned long ls : CPTE_SHIFT_SIZE,
		    ;)))
	    };

next            -   it is a pointer to next level block

golden/mask     -   mask for address to compare with golden - if matches then
		    search for end leaf can be continued on next level.
		    (if it doesn't match then PTE doesn't exist - it is a way
		     to have some kind of tree compression)
		    NOTE: The bit 0 of mask field is a flag bit, value 1 means
		    that it is an intermediate node.

pm              -   The content of CP0_PAGEMASK for next level leaf PTEs.
		    Before use this field must be shifted left to cover size of
		    both rs+ls fields (or word can be just masked)

ls and rs       -   left shift value and right shift value for address to get
		    an offset in next PTE tree level block. Low end bits must
		    be masked to get CPTE element alignment.

So, after applying left/right shifts and mask (~0xf) and adding 'next' pointer,
we have an exact pointer to next level PTE in next level PTE block. It can be
leaf node, an intermediate node or 'transient' node (see below).


Leaf node format:

	    struct cpte_dl {
		    emulator            const * const f;
		    unsigned long       const (* const bm)[];
		    unsigned long       el0;
		    unsigned long       el1;
	    };

This node is used to load TLB from PTE.

el0/el1         - it is the content of CP0_EntryLo0/1 registers
		  TLB refill exception handler stops here and load TLB with
		  EntryLo0/1 from here and PageMask from upper level intermediate
		  node. EntryHi is taken from CP0 BadVAddr.

bm              - bit mask of ALLOWABLE access if only some part of page can be
		  acccessed by guest or thread.

f               - pointer to device emulation function which emulates a device
		  supposed to be behind this page. Device can be a real device
		  with access restrictions like Interrupt Controller (IC) or
		  a pure virtual device in paravirtualized system.

If all fields are zero then it is a wrong acess by guest/thread.

If both el0/el1 are zero but 'next' is not then it indicates that subtree for
SW access emulation starts here (see below), in this case 'f' points to subtree
root entry. This PTE is named 'transient'.

If non-zero el0 or el1 causes non-refill TLB exception it means that access
emulation must be here. If 'f' is non-zero then device emulation handler is called.
And if 'bm' is non-sero then only part of page can be accessed (multiple devices
in a single page and only some of it is assigned to guest/thread).

Finally, if no 'f', no 'bm' is in CPTE but bit 'G' is in addressed elX (and no 'V')
then it means 'ignore-write' situation. Read is emulated, write is ignored.



    2.  Subtree format for fine-grained SW emulation of guest/thread device access


SW emulated intermediate PTE format is close to a regular intermediate PTE:

	    struct cpte_nd {
		    union  cpte         const * const next;
		    unsigned long       mask;
		    unsigned long       golden;
		    BITFIELD_FIELD(unsigned long pm : 20,
		    BITFIELD_FIELD(unsigned long rs : CPTE_SHIFT_SIZE,
		    BITFIELD_FIELD(unsigned long ls : CPTE_SHIFT_SIZE,
		    ;)))
	    };

next, golden/mask and ls/rs fields are the same as a regular intermediate PTE (see above).

pm              -   PAGEMASK for next level leaf PTEs.
		    In contrast to a regular intermediate PTE this field denotes
		    an exact small page mask, without any shift.
		    So, the max size of SW emulated region should be < 2**21 bytes, but
		    less that 4K page is better.

So, after applying left/right shifts and mask (~0xf) and adding 'next' pointer,
we have an exact pointer to next level PTE in next level PTE block. It can be
SW emulated leaf node, or SW emulated intermediate node.

Note: the low order bit if 'mask' is 1 to differ it from SW emulated leaf PTE.


SW emulated leaf PTE format:

	    struct cpte_dl {
		    emulator            const * const f;
		    unsigned long       const (* const bm)[];
		    unsigned long       el0;
		    unsigned long       el1;
	    };

This node is used to emulate access to device registers.

el0/el1         - it is similat to content of CP0_EntryLo0/1 registers but differs.
		  Low order bits are Cache/Dirty/UnusedV/WriteIgnore.
		    Cache bit is used to indicate "Cacheable", othervise "UNCachable" access.
		    Dirty bit allows an emulated write for guest/thread.
		    WriteIgnore allows read access but discards any write
		  The rest bits are just address of register block aligned to 16bytes, and
		  there is no RI/XI protection bits in upper bits of word.
		  Low 4 bits of address are assumed to be 0000.

bm              - bit mask of ALLOWABLE access if only some part of page can be
		  acccessed by guest or thread.

f               - pointer to device emulation function which emulates a device
		  supposed to be behind this page. Device can be a real device
		  with access restrictions like Interrupt Controller (IC) or
		  a pure virtual device in paravirtualized system.

If all fields are zero then it is a wrong acess by guest/thread.


NOTE: Each PTE covers some region and a size of that region is in line with MIPS MMU
translation requirements - address must be aligned by size etc. PageMask or/and ls/rs
are used to detect an exact PTE+elX in array of PTEs at some level. SW emulated trees are
subject of the same rule, although with slightly different elX format and smaller region
than hardware page sizes. Behind intermediate PTE there is also some memory region with
more exact granularity which is covered by next level leaf PTEs (or intermediate PTEs +
leaf PTEs).
  However, 'golden'/'mask' matching allows a significant compression of the next level PTE
array size through squeezing the memory region via this match.



PART B:     Python PTE trees generator crucial tables formats and process
--------------------------------------------------------------


    1.  Input format of memory regions

  It is some set of

	keyword = vaddress size [flags [physaddr]]

lines in main configuration file. It is described in Documentation/README.config.desc

  Lines in format:

	rom/ram = vaddress size flags ALIGNMENT

are used to indicate a memory regions for automatic allocation by Python configurator.
It is usually used for code (rom) from ELF file. RAM sizes and virtuall addrs usually
should be given manually, because this information can't be reliably extracted from ELF.

Line
	dma = address size flags

Defines a single RAM region which is assigned to work with DMA. It means that for PIC32MZEF
SoC the physical address of region must be equal to virtual, just to avoid a guest driver
paravirtualization to convert virtual address --> physical before DMA is started; PIC32MZEF
has no IOMMU for hardware assisted conversion.
  In addition, configurator also assign DMA protection for/from guest basing in this info.


    2.  Memory regions format after config file parsing

It is a list of Python tuples:

	(virtual-address, size, flags, physical-address)

After parsing devices, a configurator creates a list of PTEs, again - in form of tuples:

	(virtual-address, size, flags, physical-address, emulator)

And after taking into account the minimum physical page size 4K, it extends a small PTEs
to a full 4K but applies bitmasks to each PTE (or None for regular pages):

	(virtual-address, size, flags, physical-address, emulator, bitmask)

Finally, after some checks a configurator splits PTEs to pairs in accordance with MIPS MMU
rule of "buddy PTEs", honoring the size and alignment:

	(vaddr, size, page0-flags, page1-flags, page0-physaddr, page1-physaddr, emulator, bitmask)

then tryis to join some accepatble PTEs into bigger ones, creating vm["pteplaintree"] hash.


    3.  Creation of PTE trees

Initially, the simple PTE tree is created with a lot of intermediate nodes like:

	(vaddr-aligned-to-size, area-size-total-below-this-level, basic-slot-size-of-next-level, list-of-next-level)

basic-slot-size-of-next-level indicates a basic page size of next level - size of a single PTE of next level.
Difference between area-size-total-below-this-level and (number of list-of-next-level * basic-slot-size-of-next-level)
is used to create 'golden'/'mask' matching later.

After that the tree simplification is done. It tries to remove a single slot intermediate
level nodes, effectively pulls up some isolated small pages, adjusting a basic-slot-size-of-next-level
on upper level.

Final PTE tree has a one of simple possible structure, with biggest possible pages for contigous regions.
It still prevents some level with multiple empty holes in a middle, saving space for tree.
